---
title:  DP 02
---

문제

# subProblems 중 답이 있는 경우

    - 직관 : d[ i ] 를 구하기 위해 i 에 연관된 데이터를 꼭 포함한다.
    eg) LIS 문제에서도, A[ i ] 를 포함하는 LIS 가 D [ i ] 로 정의 된다.

## 문제 유형 - subProblem 중 답이 있는 경우 | 기하적 의미

    - 가장 큰 정사각형 찾기 https://programmers.co.kr/learn/courses/30/lessons/12905
    특이점 : d[ i ][ j ] = i,j로 끝나는 가장 큰 정사각형의 한변의 길이
    D[ i ][ j ] = min ( 오른쪽, 위쪽, 위대각 ) + 1 ( 단 , board가 0 이면 0임 )

---

## 문제 유형 LIS

    - 전체를 살핀다.
    - max
    - subproblems안에 답이 있음 - A [ i ] 를 포함해햐하는 제약

    - LIS 문제 🚀
    가장 긴 증가하는 부분 수열 문제
    d[ n ] : A[ n ] 번째 수열을 포함할때, 가장 긴 증가하는 부분 수열

    d[ n ] = max( d[ n-1 ] …. d[ 0 ] ) 단 ( A[n] > A[ k ] )일때

    for i in range(1, N + 1):
        d[i] = 1
        for j in range(1, i):
            if A[i] > A[j]:
                d[i] = max(d[i], d[j]+1)

    - 특이점
    그냥 암기 - 발상법 매우 특이함

    - LIS 문제 4

    특이점
    LIS 기존 문제에서 만들어진, 증가,부분수열을 추가적으로 기록

    - LIS 문제, 가장 큰 증가 부분 수열

특이점
가장 긴 , 증가하는, 부분수열의 최대 길이 >
가장 긴, 증가하는 , 부분수열의 최대합 으로 변경됨 -> 수열의 원소는 1보다 크므로 길이가 긴것이 최대합이 된다.

d[ n ] :수열 An을 포함하는 가장 긴 증가하는 부분수열의 최대합

for i in range(1, N):
d[i] = P[i] # 새롭게 수열을 시작하는 경우 # 탐색 0 ~ i-1 까지 , 수열을 잇는 경우 ( 조건, p[ j ] < p [ i ] )
for j in range(0, i):
if P[j] < P[i]:
d[i] = max(d[i], d[j] + P[i])

    - LIS, 가장 긴 감소하는 부분 수열

특이점 :
가장 긴 감소하는 부분 수열을 뒤집으면 된다.

    - LIS, 가장 긴 바이토닉 부분 수열

특이점 :
가장 긴 증가하는 부분수열
가장 긴 감소하는 부분수열 , 두개를 이어 붙이면 된다.

---

## 문제 유형 - 연속합

    - max
    - subproblems 안에 답, - A [ i ] 를 포함

    -  연속합 ( vs  LIS )

특이점 :
LIS : 부분 수열 | 가장 긴 증가하는
연속합 : 연속 수열 | 가장 큰 합 > 연속 수열이므로, 앞뒤만 살펴보면 된다.

d[ n ] : n번째 수열을 포함하는, 연속 수열의 최대합

d[0] = P[0]
for i in range(1, N):
d[i] = P[i] # 지금까지의 합을 버리고 새로 시작하는경우
if d[i] < d[i-1] + P[i]: # 이어서 가는 경우
d[i] = d[i-1] + P[i]

    - 연속합2

특이점 :
숫자 하나를 버릴 수 있다. ( 안버려도 된다. )

d[ n ][ k ] : n번쨰 수열을 포함하는 연속 수열의 최대 합.
k = 0 인경우는 지금까지 한번도 안버림
k = 1 인경우는 한번은 버렸다. ( n번째 수열을 버리는 경우 or k(<n)째 수열을 버렸던 경우 )

d[0][0] = P[0]
d[0][1] = P[0]  # 🤷‍♀️
for i in range(1, N):
    d[i][0] = P[i]  # 기본상태는 자기 자신, 지금까지의 합을 버리고 새로 시작하는경우
    if d[i][0] < d[i-1][0] + P[i]:
        d[i][0] = d[i-1][0] + P[i]
    # d[i][1] = 0
    # 0인 상태에서, 1로 들어오면서 ( 나를 제거하면서 ) 새로시작하는경우 ❌
    # 0인 상태에서, 1로 들어오면서 ( 나를 제거하면서 ) 잇는경우
    # 한번 제거한상태와 잇는 경우
    d[i][1] = max(d[i-1][0], d[i-1][1] + P[i])

---

## 문제유형 - 합분해

    - 합분해 🚀

특이점 - dp 공식이 개헬임. - 공식접근보다는 직관이 편한데 ? , 타일 채우기랑 비슷한데?

D[ 항의 개수 ] [ 더한 결과값 ] = D[ 항의 개수 - 1 ][ l ] ( 0 <= L <= 더한 결과값 )

// init
for (int i = 0; i <= N; i++)
{
d[1][i] = 1ll;
}

// bottom-up

    for (int i = 2; i <= k; i++)
    {
        for (int j = 0; j <= n; j++)
        {
            for (int l = 0; l <= j; l++)
            {
                d[i][j] += d[i - 1][l];
                d[i][j] = d[i][j] % DIVIDER; //FB1. &뭔제
            }
        }
    }

FB - FB Array Overflow = 실제 쓰는 배열에 영향을 준다. - FB int overflow = 값이 - 로 변한다 > long long
for (int i = 0; i <= N; i++)
{
d[1][i] = 1ll;
}

for (int i = 0; i <= 201; i++)
{
d[1][i] = 1ll;
}

## 문제 유형 - LCS

    - LCS https://www.acmicpc.net/problem/9251 🚀🚀🚀

최장 공통 부분 수열 https://mygumi.tistory.com/126

    - 알고리즘

마지막 문자열이 같은경우, 그전 LCS에서 1개를 연장한다.
LCS ( " ABCD " , " EGWD" ) = LCS ( " ABC " , " EGW" ) + 1
마지막 문자열이 다른경우, 각각 하나 적은 LCS 두개의 최대값을 취한다.
LCS ( " ABCD " , " EGWK" ) = MAX [ LCS ( " ABCD" , " EGW" ) , LCS ( " ABC " , " EGWK " ) ]

if A[i] == B[j]:  # 같은 경우
            D[i+1][j+1] = D[i][j]+1          
        else:   # 다른 경우
            D[i+1][j+1] = max(D[i+1][j], D[i][j+1])
특이점 : 발상이 어려움, 문제를 봤는데도 직관적으로 이해 불가

    - LCS 문자열 찾기 https://www.acmicpc.net/problem/9252

    특이점 : LCS 문자열을 찾는것은 다시 거슬러 올라가는데 다음 규칙을 따른다.
    1. 자신과 같은 숫자가 있는곳까지 왼쪽,위쪽으로만 따라간다.
    2. 더이상 없다면 왼위 대각선 방향이 -1 인지 체크하고 다음으로 진입한다.
