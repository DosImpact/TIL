---
title:  DP 01
---

# DP BASIC

- DP 문제 발상 : 
1. Overlapping Subproblem(문제 P는 A1,A2,... 로 같은 구조로 쪼깨짐.) 
+ 
2.Optimal Substructure (답 A는 A1,A2,... An을 통해 구함) -> 메모지에이션

- 풀이방법 : 
1. TopDown : 문제를 작은 문제로 나눈다. -> 작은 문제를 푼다. \_> 작은 문젤르 풀었으니 문제를 이제 푼다.
2. BottomUp : 문제를 크기가 작은 문제부터 차례대로 푼다. -> 문제의 크기를 조금씩 크게 만들면서 문제를 점점 푼다. -> 큰문제가 풀린다.

- 풀이 순서 :

    1. d[i] 를 문장으로 정의 한다 
    2. 변수의 갯수만큼 메모배열 만들기 
    3. d[i] 관한 식을 찾는다 
    4. 탑다운|바텀업 으로 푼다

- 문제 유형 :

### D 관계식 세우는 다양한 유형 - min,max,sum - 다음 D로 가기위해서, 지금까지 모아놨던 모든 D를 살펴야 하는 경우

### D가 다차원 배열인 경우 - 문제 조건을 D의 차원으로 분리한다.

## DP VS BF 같은 문제 다른 접근법 - 1,2,3 더하기

- 아예 접근 방식 자체가 다르다 (재귀함수 STACK(FUNC) 은 하나의 수단일뿐..)
- BF는 정답조건으로 하나씩 만들어가면서(정답인경우|아닌경우|계속경우) ( 백트래킹 - 재귀 )
- DP는 문제를 작은 문제로 만들고 작은문제간의 식을 세운다. => 바텀업(for문) 또는 탑다운(재귀)으로 해결

```
int go(int sum, int goal)
{
    if (sum == goal)
        return 1;
    if (sum > goal)
        return 0;
    int ans_node = 0;
    for (int i = 1; i <= 3; i++)
    {
        ans_node += go(sum + i, goal);
    }
    return ans_node;
}

int dp2(int n)
{
    d[1] = 1;
    d[2] = 2;
    d[3] = 4;
    for (int i = 4; i <= n; i++)
    {
        d[i] = d[i - 1] + d[i - 2] + d[i - 3];
    }
    return d[n];
}
```

    - 피보나치 문제

d[ i ] : i 번째 피보나치 수
d[ i ] = d[ i -2 ] + d[ i - 1]

특이점 : 숫자가 너무 크기때문에, 문자열을 통해 저장을 하고, 문자열간에 + 연산을 하는 함수를 작성. ( python 시간초과 / but 정수 무제한 )

    - 1로 만들기

d[ i ] : i 를 1로 만드는데 필요한 최소 연산 횟수 : 연산은 -1, //2, //3 세 종류가 있다.
d[ i ] = min ( d [ i - 1 ] , d [ i // 2 ] , d [ i // 3 ] ) + 1

특이점 : python에서 stack을 10\*\*6번 호출하니 메모리 초과가 뜬다. 무조건 bottom up 으로 for문으로 돌려야했음.

    - 타일 문제

d [ i ] = 2*i 번째 타일을 만드는 방법의 수 ( 타일의 길이를 overlap )
d [ i ] = d[ i -1 ] + d[ i -2 ]
d [ i ] = d[ i -1 ] + d[ i -2 ] *2

    - 1,2,3 더하기

d[ i ] = i 를 1,2,3 으로 나타내는 경우의 수라 정의 ( 작은 수부터 만들면서 overlap )
d[ i ] = d[ i - 1 ] + d[ i - 2 ] + d[ i - 3 ]

    - 1,2,3 더하기 5

D[ n ][ k ] = n자리수리고 k로 끝나는 수라고 정의
특이점 : 차원 1개 증가, CASE by Case 로 덧셈하면 됨

# 1을 붙이는 경우
    d[i][0] = d[i-1][1] + d[i-1][2]
    # 2를 붙이는 경우
    d[i][1] = d[i-2][0] + d[i-2][2]
    # 3을 붙이는 경우
    d[i][2] = d[i-3][0] + d[i-3][1]

    - 붕어빵 판매하기

d[ i ] = i개의 붕어빵을 팔아서 얻는 최대 수익
d[ i ] = MAX ( d[ 0 ] + p [ i ], d[ 1 ] + p[ i-1 ], ….. , d [ i -1 ] + p [ 1 ] )

특이점 : 다음의 D로 넘어가려면, 모든 D를 탐색해야함.

    - 쉬운 계단수

d[ n ][ k ] = 길이가 n개인 계단수, 단 마지막 숫자가 k 이다. ( 길이를 늘려가며 overlap )
d[ n ][ k ] = d[ n -1 ][ k -1 ] + d[ n -1 ][ k + 1 ] ( 한계단 올라가는경우, 내려가는 경우 )

특이점 : 2차원 배열로 만들어서, 문제를 overlap

    - 오르막 수

0000,0001,0002,0012 …

d[ n ][ k ] = 길이가 n인 오르막수의 갯수, 단 끝 자리 수가 k 이다.
d[ n ][ k ] = d[ n-1 ][ k ] + d[ n-1 ][ k-1 ] + … .+ d[ n-1 ][ 0 ]

특이점 : - 2차원 배열로 만들기. 문제를 2단계로 분리해서 overlap

    - 이친수

1,10,100,101, 1000, 1001

    - d[ n ][ k ] = 길이가 n인 이친수의 개수, 끝나는 숫자는 k이다.
    - d[ n ][ 1 ] = d[ n-1 ][ 0 ]    // 0으로 끝나야만 1로 늘릴 수 있다.
    - d[ n ][ 0 ] = d[ n-1 ][ 0 ] + d[ n-1 ][ 1 ]

특이점: - 2차원 배열로 분리해서 overlap

    - 스티커

    - d[ n ][ 번k ] = n째 스티커까지의 최대 점수 ( k = 0 안뜯 / 1 위뜯, / 2 아래 뜯 )
        d[i][0] = max(d[i - 1][0], d[i - 1][1], d[i - 1][2])  # 스티커를 안뜯는 경우
        d[i][1] = max(d[i - 1][0], d[i - 1][2]) + P[0][i-1]  # 위에를 뜯는경우
        d[i][2] = max(d[i - 1][0], d[i - 1][1]) + P[1][i-1]  # 아랠르 뜯는 경우

특이점 : - 스티커 문제를 앞에서부터 하나씩 때는것으로 문제를 overlapping 해나간다. - 2차원 배열로 Case를 나누어서 해결

    - 포도주 시식

최대 2잔만 연속으로 먹을때 먹은 최대 포도주 양

    - d[ n ][ k ] = n번째 까지 k번 연속으로 포도주를 먹었을때, 포도주의 최대 양

        D[i][0] = max( D[i-1][0], D[i-1][1], D[i-1][2])
        D[i][1] = D[i-1][0] + P[i]
        D[i][2] = D[i-1][1] + P[i]


    - LIS 문제
    가장 긴 증가하는 부분 수열 문제
    d[ n ] : A[ n ] 번째 수열을 포함할때, 가장 긴 증가하는 부분 수열

    d[ n ] = max( d[ n-1 ] …. d[ 0 ] ) 단 ( A[n] > A[ k ] )일때

    for i in range(1, N + 1):
        d[i] = 1
        for j in range(1, i):
            if A[i] > A[j]:
                d[i] = max(d[i], d[j]+1)

    - 특이점
    - 그냥 암기 - 발상법 매우 특이함

    - LIS 문제 4

    특이점
    - LIS 기존 문제에서 만들어진, 증가,부분수열을 추가적으로 기록

    - LIS 문제, 가장 큰 증가 부분 수열

특이점
가장 긴 , 증가하는, 부분수열의 최대 길이 >
가장 긴, 증가하는 , 부분수열의 최대합 으로 변경됨 -> 수열의 원소는 1보다 크므로 길이가 긴것이 최대합이 된다.

d[ n ] :수열 An을 포함하는 가장 긴 증가하는 부분수열의 최대합

for i in range(1, N):
d[i] = P[i] # 새롭게 수열을 시작하는 경우 # 탐색 0 ~ i-1 까지 , 수열을 잇는 경우 ( 조건, p[ j ] < p [ i ] )
for j in range(0, i):
if P[j] < P[i]:
d[i] = max(d[i], d[j] + P[i])

    - LIS, 가장 긴 감소하는 부분 수열

특이점 :
가장 긴 감소하는 부분 수열을 뒤집으면 된다.

    - LIS, 가장 긴 바이토닉 부분 수열

특이점 :
가장 긴 증가하는 부분수열
가장 긴 감소하는 부분수열 , 두개를 이어 붙이면 된다.

    -  연속합 ( vs  LIS )

특이점 :
LIS : 부분 수열 | 가장 긴 증가하는
연속합 : 연속 수열 | 가장 큰 합 > 연속 수열이므로, 앞뒤만 살펴보면 된다.

d[ n ] : n번째 수열을 포함하는, 연속 수열의 최대합

d[0] = P[0]
for i in range(1, N):
d[i] = P[i] # 지금까지의 합을 버리고 새로 시작하는경우
if d[i] < d[i-1] + P[i]: # 이어서 가는 경우
d[i] = d[i-1] + P[i]

    - 연속합2

특이점 :
숫자 하나를 버릴 수 있다. ( 안버려도 된다. )

d[ n ][ k ] : n번쨰 수열을 포함하는 연속 수열의 최대 합.
k = 0 인경우는 지금까지 한번도 안버림
k = 1 인경우는 한번은 버렸다. ( n번째 수열을 버리는 경우 or k(<n)째 수열을 버렸던 경우 )

d[0][0] = P[0]
d[0][1] = P[0]  # 🤷‍♀️
for i in range(1, N):
    d[i][0] = P[i]  # 기본상태는 자기 자신, 지금까지의 합을 버리고 새로 시작하는경우
    if d[i][0] < d[i-1][0] + P[i]:
        d[i][0] = d[i-1][0] + P[i]
    # d[i][1] = 0
    # 0인 상태에서, 1로 들어오면서 ( 나를 제거하면서 ) 새로시작하는경우 ❌
    # 0인 상태에서, 1로 들어오면서 ( 나를 제거하면서 ) 잇는경우
    # 한번 제거한상태와 잇는 경우
    d[i][1] = max(d[i-1][0], d[i-1][1] + P[i])

    - 계단오르기

한칸 이동, 한칸 점프해서 이동 단, 3번 연속 계단오르기 안됨, 이때 최대 점수

d[ n ][ k ] = n번째 계단까지 올랐을때 최대 점수, 현재 k번 연속 계단을 올랐다.

    d[i][1] = max(d[i-2][2], d[i-2][1]) + P[i]
    d[i][2] = d[i-1][1] + P[i]



    - 제곱수의 합

자연수 N을 제곱수의 합으로 나타낼때, 최소 제곱수의 항을 나타내기.

    - 특이점

0부터 N 까지 다 돌면시간초과 (2중 for문)
제곱번만 돌면 그것이 최소 제곱수의 항으로 표현이 가능하다.

d[ n ] = n번째제곱수를 나타내는 최소항의 개수

n=int(input())
dp=[n]\*(n+1)
dp[0], dp[1]=0,1

for i in range(1,n+1):
end=int(i\*\*0.5)+1

    dp[i]=min((dp[i-j*j]+1) for j in range(1, end))

print(dp[n])

    - 타일 채우기

3*N 타일을 2*1,1\*2 타일로 채워야 한다.

d[ n ] = 3\*N 타일을 채웠을때 가능한 경우의 수

특이점 - for문으로 안보이는 블럭부터 채워야 한다. - 홀수인 경우는 무조건 0 이다. - 하지만 d[ 0 ] 은 1로 basesetting

    for i in range(5, N + 1):
        if (i % 2 == 1):
            d[i] = 0
            continue
        d[i] = d[i-2]*3
        for j in range(i - 4, -1, -2):
            d[i] += (d[j] * 2)


    - 파도반 수열

특이점 - dp 공식을 찾는데 기하적 도형을 이용한다. - 그리고 dp 공식이 두가지가 나온다.

d[ n ] : n번째 삼각형의 한변의 길이
d[ n ] = d[ n - 2] + d[ n- 3]
d[ n ] = d[ n-1 ] + d[ n-4]

    - 합분해

특이점 - dp 공식이 개헬임.

D[ 항의 개수 ] [ 더한 결과값 ] = D[ 항의 개수 - 1 ][ l ] ( 0 <= L <= 더한 결과값 )

// init
for (int i = 0; i <= N; i++)
{
d[1][i] = 1ll;
}

// bottom-up

    for (int i = 2; i <= k; i++)
    {
        for (int j = 0; j <= n; j++)
        {
            for (int l = 0; l <= j; l++)
            {
                d[i][j] += d[i - 1][l];
                d[i][j] = d[i][j] % DIVIDER; //FB1. &뭔제
            }
        }
    }

FB - FB Array Overflow = 실제 쓰는 배열에 영향을 준다. - FB int overflow = 값이 - 로 변한다 > long long
for (int i = 0; i <= N; i++)
{
d[1][i] = 1ll;
}

for (int i = 0; i <= 201; i++)
{
d[1][i] = 1ll;
}

---basic

--SW1
